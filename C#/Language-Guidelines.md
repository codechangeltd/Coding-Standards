# C# Language GuidelinesThe following guidlines have been adapted from the Microsoft C#.NET guidlines. Some of the guidlines are also specific to Code Change.## VariablesUse implicit type var for local variable declarations. Exception: primitive types (int, string, double, etc) use predefined names. Also, avoid the use of var in place of dynamic.```c#var stream = File.Create(path);var customers = new Dictionary();// Exceptionsint index = 100;string timeSheet;bool isCompleted;// Also acceptablevar index = 100;var timeSheet = default(string);var isCompleted = default(bool);```Why: removes clutter, particularly with complex generic types. Type is easily detected with Visual Studio tooltips.Use predefined type names instead of system type names like Int16, Single, UInt64, etc. ```c#// Correctstring firstName;int lastIndex;bool isSaved; // AvoidString firstName;Int32 lastIndex;Boolean isSaved;```Why: consistent with the Microsoft's .NET Framework and makes code more natural to read.Use implicit typing to determine the type of the loop variable in [for](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/for) and [foreach](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/foreach-in) loops.The following example uses implicit typing in a **for** statement.```c#var syllable = "ha";var laugh = "";for (var i = 0; i < 10; i++){    laugh += syllable;    Console.WriteLine(laugh);}```The following example uses implicit typing in a **foreach** statement.```c#foreach (var ch in laugh){    if (ch == 'h')    {        Console.Write("H");    }    else    {        Console.Write(ch);    }}```## String ManipulationUse the + operator to concatenate short strings, as shown in the following code.```c#var displayName = firstName + " " + lastName;```Alternatively, use the String.Format (or the String.With extension in Change.Common) method to construct the string.```c#// String.Formatvar displayName = String.Format(    "{0} {1}",    firstName,    lastName);// Or String.Withvar displayName = "{0} {1}".With(    firstName,    lastName);```To append strings in loops, especially when you are working with large amounts of text, use a [StringBuilder](https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=netframework-4.7.1) object.```c#var phrase = "lalalalalalalalala";var builder = new StringBuilder();for (var i = 0; i < 10000; i++){    builder.Append(phrase);}```## try-catch and using Statements in Exception HandlingUse a try-catch statement for most exception handling.```c#public static string GetValueFromArray(string[] array, int index){    try    {        return array[index];    }    catch (System.IndexOutOfRangeException ex)    {        Console.WriteLine("Index is out of range: {0}", index);        throw;    }}```Simplify your code by using the C# using statement. If you have a try-finally statement in which the only code in the finally block is a call to the Dispose method, use a using statement instead.```c#// This try-finally statement only calls Dispose in the finally block.var font1 = new Font("Arial", 10.0f);try{    var charset = font1.GdiCharSet;}finally{    if (font1 != null)    {        ((IDisposable)font1).Dispose();    }}// You can do the same thing with a using statement.using (var font2 = new Font("Arial", 10.0f)){    var charset = font2.GdiCharSet;}```Note: in an [n-tier architecture](https://en.wikipedia.org/wiki/Multitier_architecture), avoid using try-catch statements in the lower layers unless absolutely necessary; and when exceptions are caught, propagate the error back through the layers so it can be handled and logged elegantly. NEVER hide an exception by catching and then ignoring it.## && and || OperatorsTo avoid exceptions and increase performance by skipping unnecessary comparisons, use && instead of & and || instead of | when you perform comparisons, as shown in the following example.```c#Console.Write("Enter a dividend: ");var dividend = Convert.ToInt32(    Console.ReadLine());Console.Write("Enter a divisor: ");var divisor = Convert.ToInt32(    Console.ReadLine());// If the divisor is 0, the second clause in the following condition// causes a run-time error. The && operator short circuits when the// first expression is false. That is, it does not evaluate the// second expression. The & operator evaluates both, and causes // a run-time error when divisor is 0.if ((divisor != 0) && (dividend / divisor > 0)){    Console.WriteLine("Quotient: {0}", dividend / divisor);}else{    Console.WriteLine("Attempted division by 0 ends up here.");}```## Static MembersCall static members by using the class name: _ClassName.StaticMember_. This practice makes code more readable by making static access clear. Do not qualify a static member defined in a base class with the name of a derived class. While that code compiles, the code readability is misleading, and the code may break in the future if you add a static member with the same name to the derived class.## ScopeScope defines the "visibility" that portions of a program have.Always define the scope of a declaration (i.e. variable, property, method, enum, interface, class or struct). The default scope is usually public, but always be explicit.```c#// Avoidclass Document{}// Insteadpublic class Document{}```Think about scope carefully. It's not always necessary to make something public; sometimes internal is a better option. Also, consider using protected instead of private if a class might be inherited.## Object ConstructionUse the concise form of object instantiation, with implicit typing, as shown in the following declaration.```c#var instance1 = new ExampleClass();```The previous line is equivalent to the following declaration.```c#ExampleClass instance2 = new ExampleClass();```Use object initializers to simplify object creation.```c#// Object initializer.var instance3 = new ExampleClass{    Name = "Desktop",    ID = 37414,    Location = "Redmond",    Age = 2.3};// Default constructor and assignment statements.var instance4 = new ExampleClass();instance4.Name = "Desktop";instance4.ID = 37414;instance4.Location = "Redmond";instance4.Age = 2.3;```When designing complex classes consider using the [factory](https://msdn.microsoft.com/en-us/library/ee817667.aspx) or [builder](http://blogs.tedneward.com/patterns/Builder-CSharp/) design patterns.## Dependency InjectionWhen a class needs one or more dependences, make sure they are injected into the object upon construction. Avoid the [Service Locator anti-pattern](http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/) unless absolutely necessary (e.g. at application start-up or in static classes).```c#public class SomeController {    private readonly IDocumentService _documentService;    public SomeController        (            IDocumentService documentService        )    {        _documentService = documentService;    }     public ActionResult Get        (            int id        )    {        var document = _documentService.GetDocument(id);        return document;    }}```In this specific case, you could set up your controller factory to use your [IoC container](https://en.wikipedia.org/wiki/Inversion_of_control) to resolve your controllers.Avoid Dependency Injection constructor madness; these are constructors that take too many dependencies, making violations of the single [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) glaringly obvious. A good guide is to keep the number to 3-4 constructor parameters. When more are required, consider refactoring your code to [Aggregate Services](http://blog.ploeh.dk/2010/02/02/RefactoringtoAggregateServices/).## MutabilityMutable and immutable are English words meaning "can change" and "cannot change" respectively. The meaning of the words is the same in the IT context; i.e.- a mutable string can be changed, and- an immutable string cannot be changed.The meanings of these words are the same in C# / .NET as in other programming languages / environments, though (obviously) the names of the types may differ, as may other details.In most cases you will want some mutability in your classes, such as an aggregate, POCO o DTO. However, in some situations you will need to make your class immutable to ensure consistency. For example, when returning the results of an operation as a custom object.When designing classes, carefully consider whether you need it to be mutable or immutable.## InheritanceWhen used correctly, inheritance can be a powerful tool. Try to make use of inheritance where applicable; but consider the inheritance hierarchy carefully when designing your classes. Don't just use inheritance for code reuse, be sure it makes sense to inherit from a class in the first place. Consider the use of the **abstract** keyword for base classes and base declarations that are almost certain to vary by their derived type.The following example demonstrates a good use of inheritance.```c#public abstract class Person{    public string Name { get; protected set; }}public class Customer : Person{    public bool ReceiveNewsletter { get; protected set; }}public class Employee : Person{    public string EmployeeNumber { get; protected set; }}```## SOLID PrinciplesAdhere to the [SOLID principles](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) where possible. In addition, try not to let classes get too bloated with thousands of lines of code. When this happens, consider splitting the classes into smaller, reusable classes.