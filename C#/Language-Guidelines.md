# C# Language GuidelinesThe following guidlines have been adapted from the Microsoft C#.NET guidlines. Some of the guidlines are also specific to Code Change.## VariablesUse implicit type var for local variable declarations. Exception: primitive types (int, string, double, etc) use predefined names. Also, avoid the use of var in place of dynamic.```c#var stream = File.Create(path);var customers = new Dictionary();// Exceptionsint index = 100;string timeSheet;bool isCompleted;// Also acceptablevar index = 100;var timeSheet = default(string);var isCompleted = default(bool);```Why: removes clutter, particularly with complex generic types. Type is easily detected with Visual Studio tooltips.Use predefined type names instead of system type names like Int16, Single, UInt64, etc. ```c#// Correctstring firstName;int lastIndex;bool isSaved; // AvoidString firstName;Int32 lastIndex;Boolean isSaved;```Why: consistent with the Microsoft's .NET Framework and makes code more natural to read.Use implicit typing to determine the type of the loop variable in [for](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/for) and [foreach](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/foreach-in) loops.The following example uses implicit typing in a **for** statement.```c#var syllable = "ha";var laugh = "";for (var i = 0; i < 10; i++){    laugh += syllable;    Console.WriteLine(laugh);}```The following example uses implicit typing in a **foreach** statement.```c#foreach (var ch in laugh){    if (ch == 'h')    {        Console.Write("H");    }    else    {        Console.Write(ch);    }}```## String ManipulationUse the + operator to concatenate short strings, as shown in the following code.```c#var displayName = firstName + " " + lastName;```Alternatively, use the String.Format (or the String.With extension in Change.Common) method to construct the string.```c#// String.Formatvar displayName = String.Format(    "{0} {1}",    firstName,    lastName);// Or String.Withvar displayName = "{0} {1}".With(    firstName,    lastName);```To append strings in loops, especially when you are working with large amounts of text, use a [StringBuilder](https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=netframework-4.7.1) object.```c#var phrase = "lalalalalalalalala";var builder = new StringBuilder();for (var i = 0; i < 10000; i++){    builder.Append(phrase);}```## try-catch and using Statements in Exception HandlingUse a try-catch statement for most exception handling.```c#public static string GetValueFromArray    (        string[] array,        int index    ){    try    {        return array[index];    }    catch (System.IndexOutOfRangeException ex)    {        Console.WriteLine("Index is out of range: {0}", index);        throw;    }}```Simplify your code by using the C# using statement. If you have a try-finally statement in which the only code in the finally block is a call to the Dispose method, use a using statement instead.```c#// This try-finally statement only calls Dispose in the finally block.var font1 = new Font("Arial", 10.0f);try{    var charset = font1.GdiCharSet;}finally{    if (font1 != null)    {        ((IDisposable)font1).Dispose();    }}// You can do the same thing with a using statement.using (var font2 = new Font("Arial", 10.0f)){    var charset = font2.GdiCharSet;}```Note: in an [n-tier architecture](https://en.wikipedia.org/wiki/Multitier_architecture), avoid using try-catch statements in the lower layers unless absolutely necessary; and when exceptions are caught, propagate the error back through the layers so it can be handled and logged elegantly. NEVER hide an exception by catching and then ignoring it.## && and || OperatorsTo avoid exceptions and increase performance by skipping unnecessary comparisons, use && instead of & and || instead of | when you perform comparisons, as shown in the following example.```c#Console.Write("Enter a dividend: ");var dividend = Convert.ToInt32(    Console.ReadLine());Console.Write("Enter a divisor: ");var divisor = Convert.ToInt32(    Console.ReadLine());// If the divisor is 0, the second clause in the following condition// causes a run-time error. The && operator short circuits when the// first expression is false. That is, it does not evaluate the// second expression. The & operator evaluates both, and causes // a run-time error when divisor is 0.if ((divisor != 0) && (dividend / divisor > 0)){    Console.WriteLine("Quotient: {0}", dividend / divisor);}else{    Console.WriteLine("Attempted division by 0 ends up here.");}```## Static MembersCall static members by using the class name: _ClassName.StaticMember_. This practice makes code more readable by making static access clear. Do not qualify a static member defined in a base class with the name of a derived class. While that code compiles, the code readability is misleading, and the code may break in the future if you add a static member with the same name to the derived class.## ScopeScope defines the "visibility" that portions of a program have.Always define the scope of a declaration (i.e. variable, property, method, enum, interface, class or struct). The default scope is usually public, but always be explicit.```c#// Avoidclass Document{}// Insteadpublic class Document{}```Think about scope carefully. It's not always necessary to make something public; sometimes internal is a better option. Also, consider using protected instead of private if a class might be inherited.## Object ConstructionUse the concise form of object instantiation, with implicit typing, as shown in the following declaration.```c#var instance1 = new ExampleClass();```The previous line is equivalent to the following declaration.```c#ExampleClass instance2 = new ExampleClass();```Use object initializers to simplify object creation.```c#// Object initializer.var instance3 = new ExampleClass{    Name = "Desktop",    ID = 37414,    Location = "Redmond",    Age = 2.3};// Default constructor and assignment statements.var instance4 = new ExampleClass();instance4.Name = "Desktop";instance4.ID = 37414;instance4.Location = "Redmond";instance4.Age = 2.3;```When designing complex classes consider using the [factory](https://msdn.microsoft.com/en-us/library/ee817667.aspx) or [builder](http://blogs.tedneward.com/patterns/Builder-CSharp/) design patterns.## Dependency InjectionWhen a class needs one or more dependences, make sure they are injected into the object upon construction. Avoid the [Service Locator anti-pattern](http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/) unless absolutely necessary (e.g. at application start-up or in static classes).```c#public class SomeController {    private readonly IDocumentService _documentService;    public SomeController        (            IDocumentService documentService        )    {        _documentService = documentService;    }     public ActionResult Get        (            int id        )    {        var document = _documentService.GetDocument(id);        return document;    }}```In this specific case, you could set up your controller factory to use your [IoC container](https://en.wikipedia.org/wiki/Inversion_of_control) to resolve your controllers.Avoid Dependency Injection constructor madness; these are constructors that take too many dependencies, making violations of the single [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) glaringly obvious. A good guide is to keep the number to 3-4 constructor parameters. When more are required, consider refactoring your code to [Aggregate Services](http://blog.ploeh.dk/2010/02/02/RefactoringtoAggregateServices/).## MutabilityMutable and immutable are English words meaning "can change" and "cannot change" respectively. The meaning of the words is the same in the IT context; i.e.- a mutable string can be changed, and- an immutable string cannot be changed.The meanings of these words are the same in C# / .NET as in other programming languages / environments, though (obviously) the names of the types may differ, as may other details.In most cases you will want some mutability in your classes, such as an aggregate, POCO or DTO. However, in some situations you will need to make your class immutable to ensure consistency. For example, when returning the results of an operation as a custom object.When designing classes, carefully consider whether you need it to be mutable or immutable.## InheritanceWhen used correctly, inheritance can be a powerful tool. Try to make use of inheritance where applicable; but consider the inheritance hierarchy carefully when designing your classes. Don't just use inheritance for code reuse, be sure it makes sense to inherit from a class in the first place. Consider the use of the **abstract** keyword for base classes and base declarations that are almost certain to vary by their derived type.The following example demonstrates a good use of inheritance.```c#public abstract class Person{    public string Name { get; protected set; }}public class Customer : Person{    public bool ReceiveNewsletter { get; protected set; }}public class Employee : Person{    public string EmployeeNumber { get; protected set; }}```## SOLID PrinciplesAdhere to the [SOLID principles](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) where possible. In addition, try not to let classes get too bloated with thousands of lines of code. When this happens, consider splitting the classes into smaller, reusable classes.